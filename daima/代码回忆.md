
修6后3崩溃1第11步，pSrc和pDst为什么会相等？

使用ai后，代码的命名非常重要

传进来的apLineup是两个100，p->u.pPair是69 100
pPair新建后两个lineup都插的，并不是只插小的，查询的时候选择小的。我想的应该是u.pPair->apLineup[0]必须比[1]小，前面这句话和这句都有“小”字，所以我把这两个概念混杂在了一起。
当apLineup是两个100时，min是1，id是100，找100的pair，在100的pair中另一半可能比100大也可能比100小，但u.pPair->apLineup[0]必须比u.pPair->apLineup[1]小。如果apLineup[1-min]和p->u.pPair->apLineup[1]（较大的，可能是apLineup[min]也可能不是）对上，在小的里面找，如果大的一样说明找到了。
此时apLineup[min]==p->u.pPair->apLineup[0]应该是相等的，这个逻辑好绕啊！

PrintFacePair可以把每个子的FacePair全打印出来

当我的思路比较清晰时，ai可以很好的补充我不知道的信息，但当我的思维比较混乱之时，ai却无法指出我的混乱之处，帮我理清思路。

理论上来说apLineup[1-min]和apLineup[min]是不相等的，p->u.pPair->apLineup[0]和[1]也是不相等的，现在apLineup[1-min]=p->u.pPair->apLineup[1]，记为x，apLineup[min]和p->u.pPair->apLineup[0]一定相等吗？假如是45 100和69 100呢？（这种情况是不可能的，如果是45 100，那么min应该选45而不会是100，现在出现了bug，导致传入的是100 100，才会出现min是100），p->u.pPair中必定有一个是apLineup[min]，因为是轮询apLineup[min]的所有pair，既然apLineup[min]不等于x，那么apLineup[min]就必须等于p->u.pPair->apLineup[0]（备忘，防止瞬间遗忘，p->u.pPair中必定有一个是apLineup[min]，因为是轮询apLineup[min]的所有pair），现在apLineup[1-min]和min的相等导致了出现apLineup[min]不等于p->u.pPair->apLineup[0]，即100≠69，感觉这里的逻辑还没有彻底想清楚。这个代码虽然是我自己写的，但已经一年半多没看了，当时的思路都忘得差不多了，晚上睡觉明天醒来时再重新理一下完整的思路。

我说的这些都是见不得光的，尤其对于高智商的人来说，这些最好没有，如果有一定要尽快忘记，太丢人了。

做agi要求你在天马行空的幻想中仍能保持思维的清晰性。

我的思路是这样的，在apLineup[]中选择一个min，然后遍历apLineup[min]中的所有pair，如果pair[1]和min的另一半apLineup[1-min]对上，那说明找到了，因为此时这个pair中既有apLineup[min]又有apLineup[1-min]，那当然就等于apLineup了。那为什么不把条件改为pair[0]和apLineup[1-min]比较呢？这样可能会出现本来已经有却找不到的情况，假设apLineup[]是69 100,那么min是69，假设69的pair有33 69，69 90，69 100，此时pair[0]是69，本来是比较pair[1]的，满足条件100=100，结果却变成了69≠100。再回过来，只要另一半apLineup[1-min]和pair中的其中一个元素相等就说明pair对应上了，如果把pair和apLineup做交叉比较肯定不会遗漏，那么既然选择pair[0]单独比较会遗漏，那为什么选择pair[1]单独比较就不会遗漏呢？

FacePair中两个棋子的存储顺序是有规律的，而非随机的。在创建新的 FacePair 时，程序会比较两个棋子（apLineup[0] 和 apLineup[1]）的 iDir 值，并总是将 iDir 较小的棋子放入 pPair->apLineup[0]，将 iDir 较大的棋子放入 pPair->apLineup[1]。这形成了一个强约定：任何一个 FacePair 对象中，apLineup[0]->iDir 一定小于 apLineup[1]->iDir。为什么这样做不会遗漏？因为根据存储约定，任何一个包含这两个棋子的 FacePair，都必然被链接在“较小方”棋子的 pFace 链表上。您不可能在“较大方”的链表中找到一个 FacePair 并且它的 apLineup[0] 是“较大方”，因为这违反了 iDir 的排序规则。我感觉我还是没有想清楚，我知道你说的是对的，但我很确定我的感觉是还没有完全搞明白。

我的反应力很慢，对于逻辑很绕的代码，我的大脑会一片空白持续很长时间，但如果只是绕不是难，慢慢的我会想明白的。

隐含条件，另一半apLineup[1-min]大于apLineup[min]，pair[0]<pair[1]。apLineup[min]的pair中，apLineup[min]可能位于pair[0]也可能位于pair[1]，这里千万要注意，min是指传进来的apLineup，而不是pair中的min，不要搞混了。如果apLineup[min]是pair[1]，那么由于apLineup[min]小于1-min，而pair[1]>pair[0]，那么pair[0]不可能是1-min，所以此时apLineup[min]不可能被选中，想要被选中只能处在pair[0]的位置。此时apLineup[min]=pair[0]，所以在pair中默认其中一个元素相等，而且位置也确定好了，只需要比较另一个位置的元素即可，即apLineup[1-min]=pair[1]。接下来的问题是如果出现bug了，即apLineup[min]=apLineup[1-min]，为什么会破坏上述的判断逻辑？

虽然我的智商不是很高，但把我这种风格的文字喂给ai或许能提升ai的基础逻辑判断能力。上述逻辑判断的问题是，在输入数据和存储数据都正常时能得得到正常的结果，但是由于判断逻辑依赖于数据的逻辑，在数据的逻辑出现问题时却无法识别出数据的问题。

如果apLineup[min]=apLineup[1-min]，apLineup[min]处在pair[1]，且pair[1]>pair[0]，此时apLineup[1-min]>pair[0],这个pair也是不可能被选中的，所以想要被选中，apLineup[min]只能处在pair[0]的位置。这里又出现容易混淆的概念，选中指的是正确答案这种客观事实，还仅仅只是代码输出的结果而不管对错？上面的论述指的应该是逻辑上的客观事实（非代码运行的客观事实）。那么为什么用apLineup[1-min]=pair[1]做判断会把这种逻辑上非法的数据选中呢？我们说要使得apLineup和pair相等必须满足2个条件，apLineup[min]和pair中的其中一个元素相等，1-min和另一个元素相等，在数据的建立和遍历这个过程中已经隐含了apLineup[min]必定与会与pair中的其中一个元素相等，只是不知道哪个，在min和1-min相等时，apLineup[1-min]=pair[1]只是重复判断了min和pair的其中一个元素比较结果，而另一个元素的比较被忽略了。最初的例子100 100和69 100，只比较了apLineup[1-min]=apLineup[min]=100=pair[1]，而pair[0]=69被忽略了。那为什么在min和1-min不相等时，pair[0]就不会被忽略呢？

以69 100和69 100为例，不相等意味着apLineup[1-min]=100不是apLineup[min]=69，所以这个判断是除apLineup[min]外的另一个元素判断，再结合min必在pair中的另一次判断，总共2次不同元素判断，满足apLineup和pair相等的所有判断条件。就是说你去判断apLineup和pair相等不是判断2次就够了的，你还要区分出这两次判断用的是不同元素，而代码把这种区分交给了数据本身的特性。再回到100 100和69 100，左边是两个相等的元素，不用区分，右边的两次判断都集中了100这个元素上，一次是pair中有apLineup[min],即pair[1]，另一次是apLineup[1-min]=pair[1]用的也是pair[1]。那为什么69 100和69 100就没这个问题呢？通过apLineup[1-min]=pair[1]=100和apLineup数据中的min不等于1-min，把pair中两个元素的相等区分成不同元素，即a=b(相等1)，c=d(相等2)，通过a≠c来区分这两个相等中的b和d是不同元素，如果a=c了，就不能保证b和d是不同元素。

判断所有不同元素的相等情况保证了不会选中错误的数据，你还需要保证正确的满足条件的数据不会被漏掉，交叉判断正好满足了这一点。那如果apLineup[1-min]≠pair[1]，会漏掉这个pair吗？

```c
FacePair *FindFacePair(Junqi* pJunqi,ChessLineup *apLineup[])
{
    FacePair *pPair;
    LinkNode *p;
    int min;

    if(apLineup[0]->iDir<apLineup[1]->iDir){
        min = 0;
    }
    else{
        min = 1;
    }

    pPair = NULL;
    for(p=apLineup[min]->pFace->pNext;!p->isHead;p=p->pNext)
    {
        if(p->u.pPair->changeFlag==CHANGE_DEAD)
        {
            continue;
        }
        if(apLineup[1-min]==p->u.pPair->apLineup[1]){
            if(apLineup[min]!=p->u.pPair->apLineup[0]){
                assert(apLineup[min]==p->u.pPair->apLineup[0]);
            }
            pPair = p->u.pPair;
            break;
        }
    }
    return pPair;
}
```

```c
FacePair *NewFacePair(Junqi* pJunqi,ChessLineup *apLineup[])
{
    FacePair *pPair;
    int iDir1,iDir2;
    LinkNode *p;
    int i;
    u8 bPrePush;

    pPair = FindFacePair(pJunqi,apLineup);
    if(pPair!=NULL){
        //用的时候再push
      //  PushStackNode(pJunqi,pPair,sizeof(FacePair),NULL);
        return pPair;
    }
    bPrePush =  pJunqi->move.bPush;
    pJunqi->move.bPush = 0;

    iDir1 = apLineup[0]->iDir;
    iDir2 = apLineup[1]->iDir;
    pPair = (FacePair*)MallocMemNode(pJunqi->mem.pFaceMem);
#if FREE_FACE
    AddFaceCnt(pJunqi,pPair);
#endif
    //PushStackNode(pJunqi,pPair,0,pJunqi->mem.pFaceMem);
    if(iDir1<iDir2){
    	pPair->apLineup[0] = apLineup[0];
    	pPair->apLineup[1] = apLineup[1];
    }
    else{
    	pPair->apLineup[0] = apLineup[1];
    	pPair->apLineup[1] = apLineup[0];
    }
    for(i=0;i<2;i++){
        p = NewLinkNode1(pJunqi->mem.pNodeMem,(void*)pPair);
        p->type = LINEUP_FACE_MOVE;
       // PushStackNode(pJunqi,p,0,pJunqi->mem.pNodeMem);
        InsertLinkNode(pJunqi,apLineup[i]->pFace,p);
    }

    //PushStackNode(pJunqi,&pJunqi->pPairSet->iNum,sizeof(int),NULL);
    pPair->iNum = pJunqi->pPairSet->iNum;
    InsertPairVec(pJunqi->pPairSet,pPair);
    pJunqi->move.bPush = bPrePush;

    return pPair;
}
```

------
```c
MovePair *InsertPathMove(Junqi* pJunqi, Vector *pMoveVec, AimMove *pAim) {

    if(有阻挡且是我方的棋)
    {
        if(是自家的棋){
            让这个子离开
        }
        else
        {
            //让对家去处理
            pMove->aimType = MOVE_LEAVE;
            InsertVector(pJunqi->move.pMoveVec, pMove);//插入到这里主要是方便以后统一清理
            SendMoveQueue(pJunqi, pMove);
        }
    }
    else{
        直接生成move
    }
}
```

看了下，应该就是这段代码，但我没觉得这个代码有什么特别的地方，算是作为一个消息队列的应用场景吧。

------
好像已经定位到代码了，我在2023年10月和2月进行架构的变更，把大量以前的代码都删了重写，我一直以为那段代码是10月前的，没想到是2月前的。既然是消息队列，肯定有Que关键字，没发现什么蛛丝马迹，看了下10月前关于容器的结构体，怎么都是aim的？没有move的。

```c
    Vector *pAimSet;
    Vector *pAimVec;
    Vector *apAimSet[4][2];
    Vector *apAimVec[4];
    AimMove *apAim[4];
    Vector *pHisAimMoveVec;
    Vector *pAttachAimVec;
    Vector *pAimQue;
    Vector *pLeaveAimVec;
    Vector *pAstSet;
```

我记得aim和move好像是在一起的，把所有文件都浏览了一遍，没找到那段代码。不会真的是2月前的代码吧，那也太久远了，还是试试吧，关键字move que aim和move是挨着的，功夫不负有心人，终于被我找到了。

```c
void SendMoveQueue(Junqi* pJunqi,MovePair *pMove)
{
    Engine *pEngine = pJunqi->pEngine;
    int iDir;

    iDir = pMove->pSrc->iDir;
    if(!pMove->aimType){
        assert(0);
    }
    InsertLinkValue1(pJunqi->mem.pNodeMem,pEngine->apMoveQue[iDir],pMove);
}

void SendAimQueue(Junqi* pJunqi,AimMove *pAim)
```

现在还不敢百分之百确定，等我把这段代码搞明白了，再盖棺定论吧。

------
有一段代码想不起来在哪里了，好像是和消息队列有关的。并不是消息队列实现起来有什么难度，而是那段代码处理的时机恰到好处，我当时被惊艳到了，由于我的代码有好几次大范围的删改，那段代码应该已经被删掉了，commit这么多，我也不知道在哪个commit找回来。

现在只好在历史版本中慢慢调试，希望能把那段代码给找回来。风险是不知道要花多少时间，也不知道我现在还有没有耐心，还有可能找回来后反而觉得平淡了，也没现在这么渴求，只要能找回来就好，最怕的就是碰到了觉得很平淡，认为不是我记忆中那段特别惊艳的代码，那就永远都找不回来了。